# Введение в System Design

## Что такое System Design?

**System Design** (системный дизайн) — это процесс определения архитектуры, компонентов, модулей, интерфейсов и данных для системы, которая удовлетворяет заданным требованиям. Это одновременно искусство и наука: нужно балансировать между различными trade-offs, выбирая оптимальные решения для конкретной задачи.

Системный дизайн отвечает на вопросы:
- Как спроектировать систему, которая будет обрабатывать миллионы запросов в секунду?
- Как обеспечить высокую доступность и отказоустойчивость?
- Как масштабировать систему при росте нагрузки?
- Как обеспечить согласованность данных в распределенной среде?
- Как минимизировать задержки и повысить производительность?

## Зачем нужен System Design?

### 1. Решение реальных бизнес-задач
Современные компании работают с огромными объемами данных и пользователей. Instagram обрабатывает миллиарды фотографий, Netflix стримит петабайты видео, Uber координирует миллионы поездок. Без продуманного системного дизайна такие сервисы просто не смогли бы функционировать.

### 2. Карьерный рост
Понимание системного дизайна — ключевой навык для продвижения от middle к senior и далее до архитектора. На собеседованиях в крупные tech-компании (Google, Meta, Amazon, Netflix) system design интервью — обязательный этап.

### 3. Экономическая эффективность
Правильный дизайн экономит деньги компании:
- Эффективное использование ресурсов снижает затраты на инфраструктуру
- Масштабируемая архитектура позволяет расти без полного переписывания
- Отказоустойчивость предотвращает финансовые потери от downtime

## Ключевые характеристики хорошо спроектированной системы

### 1. Scalability (Масштабируемость)
Способность системы справляться с ростом нагрузки путем добавления ресурсов.

**Vertical Scaling (вертикальное масштабирование)**
- Добавление мощности к существующей машине (CPU, RAM, диск)
- Проще в реализации, но имеет физические пределы
- Требует downtime для апгрейда
- Пример: переход с сервера 16GB RAM на 64GB RAM

**Horizontal Scaling (горизонтальное масштабирование)**
- Добавление новых машин в систему
- Теоретически бесконечно масштабируемо
- Усложняет архитектуру (нужны load balancers, distributed systems)
- Пример: добавление 10 новых серверов к существующим 5

### 2. Reliability (Надежность)
Вероятность того, что система продолжит работать корректно в течение определенного времени, даже при возникновении ошибок.

Метрики надежности:
- **MTBF** (Mean Time Between Failures) — среднее время между сбоями
- **MTTR** (Mean Time To Recovery) — среднее время восстановления

### 3. Availability (Доступность)
Процент времени, в течение которого система доступна для использования.

Измеряется в "девятках":
- **99% (two nines)** — downtime ~3.65 дней/год
- **99.9% (three nines)** — downtime ~8.76 часов/год
- **99.99% (four nines)** — downtime ~52.56 минут/год
- **99.999% (five nines)** — downtime ~5.26 минут/год

Формула: `Availability = Uptime / (Uptime + Downtime)`

### 4. Maintainability (Поддерживаемость)
Легкость, с которой система может быть исправлена, модифицирована или расширена.

Включает:
- Читаемость и понятность кода
- Модульность и разделение ответственности
- Документация и тесты
- Простота debugging и monitoring

### 5. Efficiency (Эффективность)
Измеряется двумя параметрами:
- **Latency (задержка)** — время ответа системы на запрос
- **Throughput (пропускная способность)** — количество операций в единицу времени

## Процесс System Design интервью

Типичное интервью длится 45-60 минут и состоит из этапов:

### 1. Уточнение требований (5-10 минут)
Задавайте вопросы, чтобы понять scope:
- Кто пользователи? Сколько их?
- Какие основные функции нужны?
- Каковы ожидаемая нагрузка и масштаб?
- Какие есть ограничения (бюджет, технологии)?

### 2. Оценка масштаба (5 минут)
Используйте back-of-the-envelope calculations:
- Количество пользователей (DAU, MAU)
- Объем данных (storage, bandwidth)
- QPS (Queries Per Second)

### 3. High-level дизайн (10-15 минут)
Набросайте основные компоненты:
- Клиенты (web, mobile, API)
- Load balancer
- Application servers
- Databases
- Caches
- CDN
- Message queues

### 4. Детализация (15-20 минут)
Углубитесь в критичные части:
- Выбор базы данных (SQL vs NoSQL)
- Схема данных
- API дизайн
- Алгоритмы и структуры данных
- Стратегии кэширования

### 5. Обсуждение bottlenecks и trade-offs (5-10 минут)
- Что может стать узким местом?
- Как система будет вести себя под нагрузкой?
- Какие компромиссы вы сделали и почему?

## Типичные Trade-offs в System Design

### 1. Consistency vs Availability (CAP теорема)
В распределенных системах при network partition нужно выбирать:
- Consistency — все узлы видят одинаковые данные
- Availability — каждый запрос получает ответ

### 2. Latency vs Throughput
Оптимизация для низкой задержки может снизить пропускную способность и наоборот.

### 3. Performance vs Scalability
Высокопроизводительное решение для одной машины может плохо масштабироваться.

### 4. Read Optimization vs Write Optimization
- Денормализация ускоряет чтение, но замедляет запись
- Нормализация упрощает запись, но замедляет чтение

### 5. Strong Consistency vs Eventual Consistency
- Strong consistency — гарантирует актуальные данные, но медленнее
- Eventual consistency — быстрее, но данные могут быть временно устаревшими

## Основные строительные блоки

При проектировании систем вы будете постоянно использовать:

1. **Load Balancers** — распределение нагрузки между серверами
2. **Caches** — ускорение доступа к часто используемым данным
3. **CDN** — доставка статического контента пользователям
4. **Databases** — хранение и управление данными
5. **Message Queues** — асинхронная обработка задач
6. **API Gateway** — единая точка входа для клиентов
7. **Microservices** — разделение функциональности на независимые сервисы

## Типичные паттерны и принципы

### Single Responsibility Principle
Каждый компонент должен иметь одну четко определенную обязанность.

### Separation of Concerns
Разделяйте систему на слои: presentation, business logic, data access.

### Fail Fast
Обнаруживайте ошибки как можно раньше и сообщайте о них явно.

### Avoid Single Points of Failure
Любой компонент может упасть — проектируйте с учетом этого.

### Stateless Services
Сервисы без состояния легче масштабировать и восстанавливать.

## Пример: проектирование URL Shortener

Давайте применим подход к простому примеру.

### Требования
- Создавать короткие URL из длинных
- Перенаправлять по коротким URL
- 100M URL генерируется в месяц
- URL никогда не истекают

### Оценка
- Запись: 100M / (30 * 24 * 3600) ≈ 40 URLs/sec
- Чтение (10x от записи): 400 URLs/sec
- Storage за 10 лет: 100M * 12 * 10 * 500 bytes ≈ 600GB

### High-level дизайн
```
[Client]
   ↓
[Load Balancer]
   ↓
[App Servers] ←→ [Cache (Redis)]
   ↓
[Database (PostgreSQL)]
```

### Ключевые решения
1. **Генерация коротких URL**: base62 encoding (a-z, A-Z, 0-9)
2. **База данных**: SQL (простая схема, ACID гарантии)
3. **Кэш**: Redis для популярных URL (80/20 rule)
4. **API**: REST
   - `POST /api/shorten` — создание
   - `GET /{shortUrl}` — редирект

## Как практиковаться

1. **Изучайте реальные системы**: прочитайте engineering blogs крупных компаний (Netflix, Uber, Airbnb)
2. **Решайте задачи**: начните с простых (URL shortener, Pastebin), переходите к сложным (YouTube, Twitter)
3. **Рисуйте диаграммы**: визуализация помогает структурировать мысли
4. **Читайте design docs**: многие компании публикуют RFC и design proposals
5. **Обсуждайте с коллегами**: разные перспективы обогащают понимание

## Рекомендуемый путь обучения

1. **Фундамент** (этот блок): базовые концепции и числа
2. **Компоненты**: детальное изучение building blocks
3. **Паттерны**: распространенные архитектурные решения
4. **Практика**: проектирование реальных систем
5. **Продакшн**: мониторинг, деплой, операции

## Что почитать дальше

### Книги
- "Designing Data-Intensive Applications" by Martin Kleppmann — библия системного дизайна
- "System Design Interview" by Alex Xu — практическое руководство для интервью
- "Building Microservices" by Sam Newman — глубокое погружение в микросервисы
- "Release It!" by Michael Nygard — patterns для production-ready систем

### Ресурсы
- [High Scalability](http://highscalability.com/) — case studies реальных систем
- [AWS Architecture Blog](https://aws.amazon.com/blogs/architecture/) — best practices от AWS
- [Martin Fowler's Blog](https://martinfowler.com/) — архитектурные паттерны
- [Uber Engineering Blog](https://eng.uber.com/) — как Uber решает проблемы scale

### Видео
- [Gaurav Sen YouTube](https://www.youtube.com/c/GauravSensei) — отличные объяснения
- [System Design Interview Channel](https://www.youtube.com/c/SystemDesignInterview)

## Проверьте себя

1. В чем разница между scalability и performance?
2. Почему горизонтальное масштабирование обычно предпочтительнее вертикального?
3. Как рассчитать availability системы, если у вас есть данные о downtime?
4. Назовите 3 основных trade-offs, с которыми вы столкнетесь при проектировании системы.
5. Какие вопросы вы бы задали первыми при проектировании новой системы?
6. Почему stateless сервисы легче масштабировать?

## Ключевые выводы

- System Design — это про поиск баланса между различными требованиями
- Не существует "правильного" решения, есть только решения с разными trade-offs
- Начинайте с простого high-level дизайна, затем детализируйте
- Всегда спрашивайте о требованиях и ограничениях
- Практика и изучение реальных систем — лучший способ обучения
- Масштабируемость, надежность и производительность — фундаментальные характеристики

---
**Следующий урок**: [Back-of-the-envelope Calculations](02-back-of-the-envelope-calculations.md)
